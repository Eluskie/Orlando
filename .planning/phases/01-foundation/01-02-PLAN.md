---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/stores/brand-store.ts
  - src/stores/chat-store.ts
  - src/stores/canvas-store.ts
  - src/stores/generation-store.ts
  - src/lib/ai/mock.ts
  - src/lib/ai/config.ts
  - src/lib/rate-limit.ts
  - src/app/api/generate/route.ts
  - tailwind.config.ts
  - src/app/globals.css
autonomous: true

must_haves:
  truths:
    - "Zustand stores are importable and functional"
    - "Mock AI mode returns fake responses without API calls"
    - "Rate limiting blocks excessive requests"
    - "Design system colors and typography are applied"
  artifacts:
    - path: "src/stores/brand-store.ts"
      provides: "Brand state management"
      exports: ["useBrandStore"]
    - path: "src/stores/chat-store.ts"
      provides: "Chat state management"
      exports: ["useChatStore"]
    - path: "src/stores/canvas-store.ts"
      provides: "Canvas state with undo/redo"
      exports: ["useCanvasStore"]
    - path: "src/stores/generation-store.ts"
      provides: "Generation queue state"
      exports: ["useGenerationStore"]
    - path: "src/lib/ai/mock.ts"
      provides: "Mock AI responses for development"
      exports: ["mockGenerate", "mockChat"]
    - path: "src/lib/rate-limit.ts"
      provides: "Rate limiting utility"
      exports: ["rateLimit", "RateLimitError"]
    - path: "src/app/api/generate/route.ts"
      provides: "Generation endpoint with rate limiting"
      exports: ["POST"]
  key_links:
    - from: "src/stores/canvas-store.ts"
      to: "zundo"
      via: "temporal middleware"
      pattern: "temporal\\("
    - from: "src/app/api/generate/route.ts"
      to: "src/lib/rate-limit.ts"
      via: "rate limit check"
      pattern: "rateLimit"
    - from: "src/lib/ai/config.ts"
      to: "src/lib/ai/mock.ts"
      via: "mock mode switch"
      pattern: "MOCK_AI_MODE"
---

<objective>
Scaffold Zustand state stores and implement cost control mechanisms.

Purpose: Establish the state architecture that prevents sync breakdown pitfalls, and implement cost controls that prevent API expense disasters during development. Mock AI mode enables rapid iteration without burning quota.

Output: Four functional Zustand stores (brand, chat, canvas, generation), working mock AI mode, rate-limited generation endpoint, and Linear/Anthropic-inspired design system.
</objective>

<execution_context>
@C:\Users\gerar\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gerar\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand stores for all domains</name>
  <files>
    - src/stores/brand-store.ts
    - src/stores/chat-store.ts
    - src/stores/canvas-store.ts
    - src/stores/generation-store.ts
  </files>
  <action>
Install zundo for undo/redo support:
```bash
npm install zundo
```

Create `src/stores/brand-store.ts`:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { Brand } from '@/lib/db/schema';
import type { BrandStyle } from '@/types/brand';

interface BrandState {
  // State
  brands: Brand[];
  activeBrandId: string | null;
  isLoading: boolean;
  error: string | null;

  // Computed
  activeBrand: () => Brand | undefined;

  // Actions
  setBrands: (brands: Brand[]) => void;
  setActiveBrand: (brandId: string | null) => void;
  addBrand: (brand: Brand) => void;
  updateBrand: (brandId: string, updates: Partial<Brand>) => void;
  updateBrandStyle: (brandId: string, style: Partial<BrandStyle>) => void;
  removeBrand: (brandId: string) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
}

export const useBrandStore = create<BrandState>()(
  persist(
    (set, get) => ({
      brands: [],
      activeBrandId: null,
      isLoading: false,
      error: null,

      activeBrand: () => {
        const state = get();
        return state.brands.find(b => b.id === state.activeBrandId);
      },

      setBrands: (brands) => set({ brands }),

      setActiveBrand: (brandId) => set({ activeBrandId: brandId }),

      addBrand: (brand) => set((state) => ({
        brands: [...state.brands, brand],
        activeBrandId: brand.id, // Auto-select new brand
      })),

      updateBrand: (brandId, updates) => set((state) => ({
        brands: state.brands.map(b =>
          b.id === brandId ? { ...b, ...updates, updatedAt: new Date() } : b
        ),
      })),

      updateBrandStyle: (brandId, style) => set((state) => ({
        brands: state.brands.map(b =>
          b.id === brandId
            ? { ...b, style: { ...b.style, ...style }, updatedAt: new Date() }
            : b
        ),
      })),

      removeBrand: (brandId) => set((state) => ({
        brands: state.brands.filter(b => b.id !== brandId),
        activeBrandId: state.activeBrandId === brandId ? null : state.activeBrandId,
      })),

      setLoading: (isLoading) => set({ isLoading }),
      setError: (error) => set({ error }),
    }),
    {
      name: 'dobra-brand-storage',
      partialize: (state) => ({
        activeBrandId: state.activeBrandId,
        // Don't persist brands - they come from DB
      }),
    }
  )
);
```

Create `src/stores/chat-store.ts`:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { ChatMessage } from '@/types/chat';

interface ChatState {
  // State
  messages: ChatMessage[];
  conversationId: string | null;
  isStreaming: boolean;
  error: string | null;

  // Actions
  setMessages: (messages: ChatMessage[]) => void;
  addMessage: (message: ChatMessage) => void;
  updateMessage: (messageId: string, updates: Partial<ChatMessage>) => void;
  setConversationId: (id: string | null) => void;
  setStreaming: (streaming: boolean) => void;
  setError: (error: string | null) => void;
  clearChat: () => void;
}

export const useChatStore = create<ChatState>()(
  persist(
    (set) => ({
      messages: [],
      conversationId: null,
      isStreaming: false,
      error: null,

      setMessages: (messages) => set({ messages }),

      addMessage: (message) => set((state) => ({
        messages: [...state.messages, message]
      })),

      updateMessage: (messageId, updates) => set((state) => ({
        messages: state.messages.map(m =>
          m.id === messageId ? { ...m, ...updates } : m
        ),
      })),

      setConversationId: (conversationId) => set({ conversationId }),
      setStreaming: (isStreaming) => set({ isStreaming }),
      setError: (error) => set({ error }),

      clearChat: () => set({
        messages: [],
        conversationId: null,
        error: null
      }),
    }),
    {
      name: 'dobra-chat-storage',
      partialize: (state) => ({
        conversationId: state.conversationId,
        // Don't persist messages in localStorage - use DB
      }),
    }
  )
);
```

Create `src/stores/canvas-store.ts`:
```typescript
import { create } from 'zustand';
import { temporal } from 'zundo';

interface CanvasObject {
  id: string;
  type: 'image' | 'placeholder' | 'reference';
  x: number;
  y: number;
  width: number;
  height: number;
  url?: string;
  status?: 'loading' | 'ready' | 'error';
  generationId?: string;
  assetId?: string;
}

interface CanvasState {
  // State
  objects: CanvasObject[];
  selectedIds: string[];
  zoom: number;
  panX: number;
  panY: number;

  // Actions
  addObject: (obj: CanvasObject) => void;
  updateObject: (id: string, updates: Partial<CanvasObject>) => void;
  removeObject: (id: string) => void;
  setObjects: (objects: CanvasObject[]) => void;
  setSelection: (ids: string[]) => void;
  clearSelection: () => void;
  setZoom: (zoom: number) => void;
  setPan: (x: number, y: number) => void;
  resetView: () => void;
}

export const useCanvasStore = create<CanvasState>()(
  temporal(
    (set) => ({
      objects: [],
      selectedIds: [],
      zoom: 1,
      panX: 0,
      panY: 0,

      addObject: (obj) => set((state) => ({
        objects: [...state.objects, obj]
      })),

      updateObject: (id, updates) => set((state) => ({
        objects: state.objects.map(obj =>
          obj.id === id ? { ...obj, ...updates } : obj
        ),
      })),

      removeObject: (id) => set((state) => ({
        objects: state.objects.filter(obj => obj.id !== id),
        selectedIds: state.selectedIds.filter(sid => sid !== id),
      })),

      setObjects: (objects) => set({ objects }),

      setSelection: (ids) => set({ selectedIds: ids }),

      clearSelection: () => set({ selectedIds: [] }),

      setZoom: (zoom) => set({ zoom: Math.min(Math.max(zoom, 0.1), 3) }), // Clamp 0.1-3x

      setPan: (panX, panY) => set({ panX, panY }),

      resetView: () => set({ zoom: 1, panX: 0, panY: 0 }),
    }),
    { limit: 50 } // Keep 50 states for undo
  )
);

// Export temporal methods for undo/redo
export const canvasUndo = () => useCanvasStore.temporal.getState().undo();
export const canvasRedo = () => useCanvasStore.temporal.getState().redo();
export const canvasClearHistory = () => useCanvasStore.temporal.getState().clear();
```

Create `src/stores/generation-store.ts`:
```typescript
import { create } from 'zustand';
import type { Generation } from '@/lib/db/schema';
import type { GenerationStatus } from '@/types/generation';

interface GenerationState {
  // State
  pendingGenerations: Generation[];
  completedGenerations: Generation[];
  activeGenerationId: string | null;
  dailyCount: number;
  dailyLimit: number;

  // Actions
  addGeneration: (generation: Generation) => void;
  updateGeneration: (id: string, updates: Partial<Generation>) => void;
  moveToCompleted: (id: string) => void;
  removeGeneration: (id: string) => void;
  setActiveGeneration: (id: string | null) => void;
  setGenerations: (pending: Generation[], completed: Generation[]) => void;
  incrementDailyCount: () => void;
  resetDailyCount: () => void;

  // Computed
  canGenerate: () => boolean;
  remainingGenerations: () => number;
}

const DEFAULT_DAILY_LIMIT = 50; // Configurable per environment

export const useGenerationStore = create<GenerationState>()((set, get) => ({
  pendingGenerations: [],
  completedGenerations: [],
  activeGenerationId: null,
  dailyCount: 0,
  dailyLimit: DEFAULT_DAILY_LIMIT,

  addGeneration: (generation) => set((state) => ({
    pendingGenerations: [...state.pendingGenerations, generation],
    activeGenerationId: generation.id,
  })),

  updateGeneration: (id, updates) => set((state) => ({
    pendingGenerations: state.pendingGenerations.map(g =>
      g.id === id ? { ...g, ...updates } : g
    ),
    completedGenerations: state.completedGenerations.map(g =>
      g.id === id ? { ...g, ...updates } : g
    ),
  })),

  moveToCompleted: (id) => set((state) => {
    const generation = state.pendingGenerations.find(g => g.id === id);
    if (!generation) return state;
    return {
      pendingGenerations: state.pendingGenerations.filter(g => g.id !== id),
      completedGenerations: [generation, ...state.completedGenerations],
      activeGenerationId: state.activeGenerationId === id ? null : state.activeGenerationId,
    };
  }),

  removeGeneration: (id) => set((state) => ({
    pendingGenerations: state.pendingGenerations.filter(g => g.id !== id),
    completedGenerations: state.completedGenerations.filter(g => g.id !== id),
    activeGenerationId: state.activeGenerationId === id ? null : state.activeGenerationId,
  })),

  setActiveGeneration: (id) => set({ activeGenerationId: id }),

  setGenerations: (pending, completed) => set({
    pendingGenerations: pending,
    completedGenerations: completed,
  }),

  incrementDailyCount: () => set((state) => ({
    dailyCount: state.dailyCount + 1
  })),

  resetDailyCount: () => set({ dailyCount: 0 }),

  canGenerate: () => {
    const state = get();
    return state.dailyCount < state.dailyLimit;
  },

  remainingGenerations: () => {
    const state = get();
    return Math.max(0, state.dailyLimit - state.dailyCount);
  },
}));
```
  </action>
  <verify>
Create a test file to verify imports work:
```typescript
// Temporary test: src/test-stores.ts
import { useBrandStore } from '@/stores/brand-store';
import { useChatStore } from '@/stores/chat-store';
import { useCanvasStore, canvasUndo, canvasRedo } from '@/stores/canvas-store';
import { useGenerationStore } from '@/stores/generation-store';
console.log('All stores import successfully');
```
Run `npx tsc --noEmit` - no TypeScript errors.
  </verify>
  <done>
Four Zustand stores scaffolded: brand-store (with persistence for active brand), chat-store (with persistence for conversation ID), canvas-store (with zundo undo/redo), generation-store (with daily limit tracking).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement mock AI mode and rate limiting</name>
  <files>
    - src/lib/ai/mock.ts
    - src/lib/ai/config.ts
    - src/lib/rate-limit.ts
    - src/app/api/generate/route.ts
  </files>
  <action>
Create `src/lib/ai/config.ts`:
```typescript
// AI configuration with mock mode support
// Set MOCK_AI_MODE=true in .env.local for development without API costs

export const AI_CONFIG = {
  mockMode: process.env.MOCK_AI_MODE === 'true',

  // Rate limits
  maxRequestsPerMinute: 10,
  maxRequestsPerDay: 50,

  // Generation settings
  defaultModel: 'imagen-3.0-generate-001',
  defaultAspectRatio: '1:1',

  // Delays for mock mode (simulate real API timing)
  mockDelayMs: {
    chat: 500,
    generation: 3000, // Imagen typically takes 5-15s, mock faster
  },
};

export const isMockMode = () => AI_CONFIG.mockMode;
```

Add to `.env.local`:
```
MOCK_AI_MODE=true
```

Add to `.env.example`:
```
MOCK_AI_MODE=true
```

Create `src/lib/ai/mock.ts`:
```typescript
import { AI_CONFIG } from './config';

// Mock responses for development without API costs

export interface MockGenerationResult {
  id: string;
  url: string;
  prompt: string;
  status: 'completed';
}

export interface MockChatResponse {
  id: string;
  role: 'assistant';
  content: string;
}

// Placeholder image URLs for mock generations
const MOCK_IMAGES = [
  'https://placehold.co/512x512/6366f1/white?text=Generated+1',
  'https://placehold.co/512x512/8b5cf6/white?text=Generated+2',
  'https://placehold.co/512x512/ec4899/white?text=Generated+3',
  'https://placehold.co/512x512/14b8a6/white?text=Generated+4',
];

const MOCK_CHAT_RESPONSES = [
  "I'd be happy to help you create a brand identity. Could you tell me more about your brand's personality and target audience?",
  "That's a great starting point! Based on what you've shared, I'm thinking of a clean, modern aesthetic with bold accent colors. Would you like me to analyze some reference images?",
  "I've noted those preferences. Let me help you generate some initial assets that match your brand style.",
  "Your brand style is coming together nicely. The combination of those colors and that typography creates a professional yet approachable feel.",
];

export async function mockGenerate(prompt: string): Promise<MockGenerationResult> {
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, AI_CONFIG.mockDelayMs.generation));

  const randomImage = MOCK_IMAGES[Math.floor(Math.random() * MOCK_IMAGES.length)];

  return {
    id: `mock-gen-${Date.now()}`,
    url: randomImage,
    prompt,
    status: 'completed',
  };
}

export async function mockChat(message: string): Promise<MockChatResponse> {
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, AI_CONFIG.mockDelayMs.chat));

  const randomResponse = MOCK_CHAT_RESPONSES[Math.floor(Math.random() * MOCK_CHAT_RESPONSES.length)];

  return {
    id: `mock-msg-${Date.now()}`,
    role: 'assistant',
    content: randomResponse,
  };
}

export function getMockStyleExtraction() {
  return {
    primaryColor: '#6366f1',
    secondaryColor: '#f1f5f9',
    accentColor: '#ec4899',
    fontFamily: 'Inter',
    headingFont: 'Inter',
    tone: 'modern',
    keywords: ['clean', 'minimal', 'professional'],
  };
}
```

Create `src/lib/rate-limit.ts`:
```typescript
// Simple in-memory rate limiting
// For production, use Redis-based rate limiting

interface RateLimitEntry {
  count: number;
  resetTime: number;
}

const rateLimitStore = new Map<string, RateLimitEntry>();

export class RateLimitError extends Error {
  public retryAfter: number;

  constructor(retryAfter: number) {
    super(`Rate limit exceeded. Try again in ${retryAfter} seconds.`);
    this.name = 'RateLimitError';
    this.retryAfter = retryAfter;
  }
}

interface RateLimitConfig {
  maxRequests: number;
  windowMs: number;
}

export function rateLimit(
  identifier: string,
  config: RateLimitConfig = { maxRequests: 10, windowMs: 60000 }
): { success: boolean; remaining: number; resetIn: number } {
  const now = Date.now();
  const entry = rateLimitStore.get(identifier);

  // Clean up expired entries periodically
  if (rateLimitStore.size > 1000) {
    for (const [key, value] of rateLimitStore.entries()) {
      if (value.resetTime < now) {
        rateLimitStore.delete(key);
      }
    }
  }

  if (!entry || entry.resetTime < now) {
    // Create new window
    rateLimitStore.set(identifier, {
      count: 1,
      resetTime: now + config.windowMs,
    });
    return {
      success: true,
      remaining: config.maxRequests - 1,
      resetIn: Math.ceil(config.windowMs / 1000),
    };
  }

  if (entry.count >= config.maxRequests) {
    const resetIn = Math.ceil((entry.resetTime - now) / 1000);
    return {
      success: false,
      remaining: 0,
      resetIn,
    };
  }

  entry.count++;
  return {
    success: true,
    remaining: config.maxRequests - entry.count,
    resetIn: Math.ceil((entry.resetTime - now) / 1000),
  };
}

// Helper to check without consuming a request
export function checkRateLimit(
  identifier: string,
  config: RateLimitConfig = { maxRequests: 10, windowMs: 60000 }
): { allowed: boolean; remaining: number } {
  const entry = rateLimitStore.get(identifier);
  const now = Date.now();

  if (!entry || entry.resetTime < now) {
    return { allowed: true, remaining: config.maxRequests };
  }

  return {
    allowed: entry.count < config.maxRequests,
    remaining: Math.max(0, config.maxRequests - entry.count),
  };
}
```

Create `src/app/api/generate/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { rateLimit, RateLimitError } from '@/lib/rate-limit';
import { isMockMode } from '@/lib/ai/config';
import { mockGenerate } from '@/lib/ai/mock';

export async function POST(request: NextRequest) {
  try {
    // Get client identifier (IP or session)
    const clientId = request.headers.get('x-forwarded-for') ||
                     request.headers.get('x-real-ip') ||
                     'anonymous';

    // Rate limit check
    const rateLimitResult = rateLimit(clientId, {
      maxRequests: 10,
      windowMs: 60000, // 1 minute
    });

    if (!rateLimitResult.success) {
      return NextResponse.json(
        {
          error: 'Rate limit exceeded',
          retryAfter: rateLimitResult.resetIn,
          remaining: 0,
        },
        {
          status: 429,
          headers: {
            'Retry-After': String(rateLimitResult.resetIn),
            'X-RateLimit-Remaining': '0',
          },
        }
      );
    }

    const body = await request.json();
    const { prompt, brandId, assetType = 'illustration' } = body;

    if (!prompt) {
      return NextResponse.json(
        { error: 'Prompt is required' },
        { status: 400 }
      );
    }

    // Use mock mode for development
    if (isMockMode()) {
      const result = await mockGenerate(prompt);
      return NextResponse.json({
        ...result,
        brandId,
        assetType,
        mock: true,
      }, {
        headers: {
          'X-RateLimit-Remaining': String(rateLimitResult.remaining),
        },
      });
    }

    // Real implementation placeholder
    // TODO: Implement actual Google Imagen API call in Phase 5
    return NextResponse.json(
      { error: 'Real generation not yet implemented. Set MOCK_AI_MODE=true' },
      { status: 501 }
    );

  } catch (error) {
    console.error('Generation error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// GET endpoint to check rate limit status
export async function GET(request: NextRequest) {
  const clientId = request.headers.get('x-forwarded-for') ||
                   request.headers.get('x-real-ip') ||
                   'anonymous';

  const { allowed, remaining } = await import('@/lib/rate-limit').then(m =>
    m.checkRateLimit(clientId, { maxRequests: 10, windowMs: 60000 })
  );

  return NextResponse.json({
    allowed,
    remaining,
    limit: 10,
    windowMs: 60000,
  });
}
```
  </action>
  <verify>
Run `npm run dev` and test:
1. `curl -X POST http://localhost:3000/api/generate -H "Content-Type: application/json" -d '{"prompt":"test image"}'` - returns mock generation with `mock: true`
2. Run the same curl 11 times rapidly - 11th request returns 429 status
3. `curl http://localhost:3000/api/generate` - returns rate limit status
  </verify>
  <done>
Mock AI mode implemented with configurable delays. Rate limiting active on generation endpoint (10 requests/minute). Generation endpoint returns mock images when MOCK_AI_MODE=true.
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure design system (Linear/Anthropic aesthetic)</name>
  <files>
    - tailwind.config.ts
    - src/app/globals.css
  </files>
  <action>
Update `tailwind.config.ts` to establish design system:
```typescript
import type { Config } from "tailwindcss";

export default {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      // Linear/Anthropic-inspired color palette
      colors: {
        // Neutral grays (similar to Linear's gray scale)
        gray: {
          50: '#fafafa',
          100: '#f5f5f5',
          150: '#ededed',
          200: '#e5e5e5',
          300: '#d4d4d4',
          400: '#a3a3a3',
          500: '#737373',
          600: '#525252',
          700: '#404040',
          800: '#262626',
          850: '#1f1f1f',
          900: '#171717',
          950: '#0a0a0a',
        },
        // Primary brand color (indigo, like Anthropic)
        primary: {
          50: '#eef2ff',
          100: '#e0e7ff',
          200: '#c7d2fe',
          300: '#a5b4fc',
          400: '#818cf8',
          500: '#6366f1',
          600: '#4f46e5',
          700: '#4338ca',
          800: '#3730a3',
          900: '#312e81',
          950: '#1e1b4b',
        },
        // Accent colors for states
        success: {
          50: '#f0fdf4',
          500: '#22c55e',
          600: '#16a34a',
        },
        warning: {
          50: '#fffbeb',
          500: '#f59e0b',
          600: '#d97706',
        },
        error: {
          50: '#fef2f2',
          500: '#ef4444',
          600: '#dc2626',
        },
      },
      // Typography
      fontFamily: {
        sans: ['var(--font-inter)', 'system-ui', 'sans-serif'],
      },
      fontSize: {
        '2xs': ['0.625rem', { lineHeight: '0.875rem' }],
      },
      // Spacing
      spacing: {
        '18': '4.5rem',
        '88': '22rem',
        '128': '32rem',
      },
      // Border radius (sharper for Linear-like aesthetic)
      borderRadius: {
        'sm': '0.25rem',
        'DEFAULT': '0.375rem',
        'md': '0.5rem',
        'lg': '0.625rem',
        'xl': '0.75rem',
      },
      // Box shadow (subtle, like Linear)
      boxShadow: {
        'subtle': '0 1px 2px 0 rgb(0 0 0 / 0.03)',
        'soft': '0 2px 8px -2px rgb(0 0 0 / 0.05), 0 4px 12px -4px rgb(0 0 0 / 0.05)',
        'card': '0 1px 3px 0 rgb(0 0 0 / 0.02), 0 1px 2px -1px rgb(0 0 0 / 0.02)',
        'elevated': '0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05)',
      },
      // Animation
      animation: {
        'fade-in': 'fadeIn 0.2s ease-out',
        'slide-up': 'slideUp 0.2s ease-out',
        'pulse-subtle': 'pulseSubtle 2s infinite',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { opacity: '0', transform: 'translateY(4px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        pulseSubtle: {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '0.7' },
        },
      },
    },
  },
  plugins: [],
} satisfies Config;
```

Update `src/app/globals.css`:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Light mode defaults */
    --background: 255 255 255;
    --foreground: 23 23 23;
    --muted: 245 245 245;
    --muted-foreground: 115 115 115;
    --border: 229 229 229;
    --ring: 99 102 241;
  }

  /* Uncomment for dark mode support later
  .dark {
    --background: 23 23 23;
    --foreground: 250 250 250;
    --muted: 38 38 38;
    --muted-foreground: 163 163 163;
    --border: 64 64 64;
    --ring: 99 102 241;
  }
  */

  * {
    @apply border-gray-200;
  }

  body {
    @apply bg-white text-gray-900 antialiased;
    font-feature-settings: "cv02", "cv03", "cv04", "cv11";
  }

  /* Focus styles */
  :focus-visible {
    @apply outline-none ring-2 ring-primary-500 ring-offset-2;
  }

  /* Selection */
  ::selection {
    @apply bg-primary-100 text-primary-900;
  }
}

@layer components {
  /* Button base */
  .btn {
    @apply inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors;
    @apply focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2;
    @apply disabled:pointer-events-none disabled:opacity-50;
  }

  .btn-primary {
    @apply btn bg-primary-600 text-white hover:bg-primary-700 active:bg-primary-800;
  }

  .btn-secondary {
    @apply btn bg-gray-100 text-gray-900 hover:bg-gray-200 active:bg-gray-300;
  }

  .btn-ghost {
    @apply btn hover:bg-gray-100 active:bg-gray-200;
  }

  /* Input base */
  .input {
    @apply flex h-10 w-full rounded-md border border-gray-200 bg-white px-3 py-2 text-sm;
    @apply placeholder:text-gray-400;
    @apply focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-0 focus-visible:border-primary-500;
    @apply disabled:cursor-not-allowed disabled:opacity-50;
  }

  /* Card */
  .card {
    @apply rounded-lg border border-gray-200 bg-white shadow-card;
  }

  /* Loading spinner */
  .spinner {
    @apply animate-spin rounded-full border-2 border-gray-200 border-t-primary-600;
  }
}

@layer utilities {
  /* Hide scrollbar but keep functionality */
  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }

  /* Subtle text gradient */
  .text-gradient {
    @apply bg-clip-text text-transparent bg-gradient-to-r from-primary-600 to-primary-400;
  }
}
```

Update `src/app/page.tsx` to demonstrate design system:
```typescript
export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24 bg-gray-50">
      <div className="text-center space-y-8">
        <div>
          <h1 className="text-4xl font-bold tracking-tight text-gray-900 mb-2">
            Dobra
          </h1>
          <p className="text-lg text-gray-500">
            Brand style consistency platform
          </p>
        </div>

        <div className="flex gap-3 justify-center">
          <button className="btn-primary px-4 py-2">
            Get Started
          </button>
          <button className="btn-secondary px-4 py-2">
            Learn More
          </button>
        </div>

        <div className="card p-6 max-w-md mx-auto">
          <h2 className="text-sm font-medium text-gray-900 mb-2">
            Phase 1: Foundation
          </h2>
          <p className="text-sm text-gray-500">
            Database schema, state architecture, and cost controls are ready.
          </p>
          <div className="mt-4 flex items-center gap-2">
            <div className="h-2 w-2 rounded-full bg-success-500"></div>
            <span className="text-xs text-gray-400">Setup complete</span>
          </div>
        </div>

        <p className="text-xs text-gray-400">
          Design system: Linear/Anthropic aesthetic
        </p>
      </div>
    </main>
  );
}
```
  </action>
  <verify>
Run `npm run dev` and visit http://localhost:3000:
1. Page displays with Inter font
2. Button styles show primary (indigo) and secondary (gray) variants
3. Card has subtle shadow and rounded corners
4. Color palette follows Linear-like muted aesthetic
5. Focus states show ring on tab navigation
  </verify>
  <done>
Design system configured with Linear/Anthropic-inspired colors, typography (Inter), spacing, and component classes. Base styles for buttons, inputs, cards defined.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. All store files import without TypeScript errors
3. `curl -X POST localhost:3000/api/generate -H "Content-Type: application/json" -d '{"prompt":"test"}'` returns mock generation
4. Rate limiting triggers on 11th rapid request (returns 429)
5. Homepage shows design system styles (colors, typography, shadows)
6. `MOCK_AI_MODE=true` in .env.local enables mock responses
</verification>

<success_criteria>
- Four Zustand stores scaffolded (brand, chat, canvas, generation)
- Canvas store has undo/redo via zundo middleware
- Generation store tracks daily limits
- Mock AI mode returns fake responses without API calls
- Rate limiting blocks >10 requests/minute to generation endpoint
- Design system follows Linear/Anthropic aesthetic (muted colors, Inter font, subtle shadows)
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
