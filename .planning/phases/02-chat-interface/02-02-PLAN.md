---
phase: 02-chat-interface
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/(chat)/[brandId]/page.tsx
  - src/app/(chat)/page.tsx
  - src/components/chat/chat-messages.tsx
  - src/components/chat/chat-input.tsx
  - src/components/chat/message-item.tsx
  - src/components/chat/typing-indicator.tsx
  - src/components/chat/chat-layout.tsx
autonomous: true

must_haves:
  truths:
    - "User can type a message and send it"
    - "User sees messages appear with streaming text"
    - "User sees typing indicator while AI responds"
    - "Messages render with minimal Claude-like styling"
    - "Chat is full-width centered when brand has no content"
    - "Chat shrinks to left panel when brand has content (canvas placeholder visible)"
  artifacts:
    - path: "src/components/chat/chat-messages.tsx"
      provides: "Message list with auto-scroll"
      min_lines: 40
    - path: "src/components/chat/chat-input.tsx"
      provides: "Text input with send button"
      min_lines: 30
    - path: "src/components/chat/message-item.tsx"
      provides: "Single message rendering with markdown"
      min_lines: 25
    - path: "src/components/chat/typing-indicator.tsx"
      provides: "Pulsing dots animation"
      min_lines: 15
    - path: "src/components/chat/chat-layout.tsx"
      provides: "Adaptive layout wrapper for chat/canvas split"
      min_lines: 30
  key_links:
    - from: "src/app/(chat)/[brandId]/page.tsx"
      to: "/api/chat"
      via: "useChat hook with DefaultChatTransport"
      pattern: "useChat|DefaultChatTransport"
    - from: "src/components/chat/message-item.tsx"
      to: "react-markdown"
      via: "markdown rendering"
      pattern: "ReactMarkdown"
    - from: "src/components/chat/chat-layout.tsx"
      to: "brand content check"
      via: "conditional layout based on hasContent prop"
      pattern: "hasContent.*w-\\[350px\\]|max-w-3xl"
---

<objective>
Build the chat UI components with streaming message display, Claude-like minimal styling, and adaptive layout that shifts when brand has content

Purpose: Enable users to have a conversation with streaming responses. This is the core chat experience that will be used for brand creation in Plan 03. The layout prepares for Phase 4 canvas integration by implementing the adaptive shift behavior now.

Output:
- ChatMessages component with auto-scroll
- ChatInput with send button and disabled attachment placeholder
- MessageItem with markdown rendering (bold, lists)
- TypingIndicator with animated dots
- ChatLayout wrapper with adaptive width (full-width centered vs left panel)
- Working chat interface at /[brandId] route
</objective>

<execution_context>
@C:\Users\gerar\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gerar\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-chat-interface/02-CONTEXT.md
@.planning/phases/02-chat-interface/02-RESEARCH.md
@.planning/phases/02-chat-interface/02-01-SUMMARY.md

# Existing code to reference
@src/app/(chat)/layout.tsx
@src/app/api/chat/route.ts
@src/app/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat UI components</name>
  <files>
    src/components/chat/chat-messages.tsx
    src/components/chat/chat-input.tsx
    src/components/chat/message-item.tsx
    src/components/chat/typing-indicator.tsx
    src/app/globals.css
  </files>
  <action>
Create the chat components following CONTEXT.md decisions and RESEARCH.md patterns:

1. Install required packages:
   ```
   npm install @ai-sdk/react react-markdown remark-gfm
   ```

2. Create `src/components/chat/typing-indicator.tsx`:
   - Three animated dots with staggered animation
   - Use CSS keyframes (add to globals.css if needed)
   - Match iMessage-style pulsing effect
   - Component accepts no props, just renders dots

3. Create `src/components/chat/message-item.tsx`:
   - 'use client' directive
   - Props: message (UIMessage from @ai-sdk/react), isStreaming (boolean)
   - Claude-like minimal styling: no bubbles, left-aligned
   - User messages: subtle bg-gray-50 background
   - Assistant messages: white background
   - Show role label ("You" or "Dobra") above message
   - Render message.parts using ReactMarkdown with remark-gfm
   - Handle text parts only (filter other part types)
   - Use prose prose-sm for typography

4. Create `src/components/chat/chat-messages.tsx`:
   - 'use client' directive
   - Props: messages (UIMessage[]), isStreaming (boolean)
   - Scrollable container (overflow-y-auto, flex-1)
   - Map messages to MessageItem components
   - Show TypingIndicator when isStreaming AND last message is from user
   - Implement auto-scroll: scroll to bottom on new messages
   - Use useRef for container, useEffect to scroll
   - Only auto-scroll if user is near bottom (within 100px)

5. Create `src/components/chat/chat-input.tsx`:
   - 'use client' directive
   - Props: onSend (text: string) => void, disabled (boolean), onStop () => void
   - Controlled input with local state
   - Send button (lucide-react Send icon)
   - Disabled attachment button (lucide-react Paperclip icon) with tooltip "Coming in Phase 3"
   - Submit on Enter (not Shift+Enter), clear input after send
   - Disable input and show Stop button when disabled=true
   - Use design system input and btn classes

6. Add typing indicator keyframes to `src/app/globals.css` if not present:
   ```css
   @keyframes typing-dot {
     0%, 100% { opacity: 0.3; transform: translateY(0); }
     50% { opacity: 1; transform: translateY(-4px); }
   }
   ```
  </action>
  <verify>
Components should compile without TypeScript errors:
`npx tsc --noEmit`
  </verify>
  <done>
All four chat components created. TypingIndicator animates. MessageItem renders markdown. ChatMessages auto-scrolls. ChatInput handles submit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create adaptive layout and wire chat UI to API</name>
  <files>
    src/components/chat/chat-layout.tsx
    src/app/(chat)/[brandId]/page.tsx
    src/app/(chat)/page.tsx
  </files>
  <action>
Create the adaptive layout wrapper and connect chat components to the API:

1. Create `src/components/chat/chat-layout.tsx`:
   - 'use client' directive
   - Props: hasContent (boolean), children (React.ReactNode)
   - Implements the CONTEXT.md layout shift decision:
     * When hasContent=false: Chat is full-width centered (max-w-3xl mx-auto) like Claude.ai
     * When hasContent=true: Chat shrinks to left panel (w-[350px] flex-shrink-0 border-r)
       and remaining space shows a placeholder div for future canvas
   - Layout structure when hasContent=true:
     ```
     <div className="flex h-full">
       <div className="w-[350px] flex-shrink-0 border-r flex flex-col">
         {children}  {/* Chat panel */}
       </div>
       <div className="flex-1 flex items-center justify-center bg-gray-50">
         <p className="text-gray-400">Canvas will appear here</p>
       </div>
     </div>
     ```
   - Layout structure when hasContent=false:
     ```
     <div className="max-w-3xl mx-auto h-full flex flex-col">
       {children}
     </div>
     ```

2. Update `src/app/(chat)/[brandId]/page.tsx`:
   - 'use client' directive
   - Import useChat from '@ai-sdk/react'
   - Import DefaultChatTransport from 'ai'
   - Import chat components: ChatMessages, ChatInput, ChatLayout
   - Get brandId from params
   - Determine hasContent: For Phase 2, check if brand has any canvas assets
     * For now, use a simple heuristic: brand.hasContent or check if brandStore.brands
       has the brand with a non-empty canvasAssets array (will be empty for new brands)
     * Default to false for Phase 2 (no canvas assets exist yet)
     * In Phase 4, this will check actual canvas asset existence
   - Initialize useChat with:
     * id: brandId (unique per brand)
     * transport: new DefaultChatTransport({ api: '/api/chat', body: { brandId } })
   - Destructure: messages, sendMessage, status, stop
   - Compute isLoading = status === 'submitted' || status === 'streaming'
   - Wrap everything in ChatLayout with hasContent prop
   - Render:
     * ChatMessages takes flex-1 with messages and isStreaming={status === 'streaming'}
     * ChatInput at bottom with onSend, disabled={isLoading}, onStop={stop}

3. Update `src/app/(chat)/page.tsx`:
   - This is the "no brand selected" state (new chat)
   - Use ChatLayout with hasContent=false (new brands start centered)
   - Use useChat with id='new' and no brandId
   - When user sends first message, stay on this page
   - The brand creation flow (Plan 03) will handle creating brand and redirecting
   - Welcome text: "Send a message to start creating your first brand"
  </action>
  <verify>
Run `npm run dev`, navigate to http://localhost:3000.
1. Type a message and press Enter
2. See typing indicator appear
3. See AI response stream in word-by-word
4. Messages styled cleanly (no bubbles, role labels)
5. Auto-scroll works on new messages
6. Chat is centered (max-w-3xl) since no brand has content yet
  </verify>
  <done>
Chat interface fully functional with adaptive layout. Chat is full-width centered for brands without content. Layout will shrink to left panel when hasContent=true (ready for Phase 4 canvas). User can send messages and receive streaming responses.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` passes
2. Full chat flow works: type -> send -> see streaming response
3. Markdown renders (try sending "Make a **bold** list: 1. First 2. Second")
4. Typing indicator visible during response generation
5. Auto-scroll works, doesn't fight with user scroll
6. Chat layout is centered (max-w-3xl) for new/empty brands
7. ChatLayout component exists and handles hasContent prop
</verification>

<success_criteria>
- User can type message in input and send with Enter or button
- Messages stream in real-time (not all at once)
- Typing indicator shows while waiting for/during response
- Messages styled minimally like Claude (no bubbles)
- Markdown bold and lists render correctly
- Attachment button visible but disabled with tooltip
- Chat is full-width centered when brand has no content
- ChatLayout component ready to shift layout when hasContent=true
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-interface/02-02-SUMMARY.md`
</output>
