---
phase: 02-chat-interface
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/app/api/chat/route.ts
  - src/app/api/brands/route.ts
  - src/app/api/conversations/[conversationId]/messages/route.ts
  - src/components/chat/brand-card.tsx
  - src/components/chat/chat-messages.tsx
  - src/app/(chat)/page.tsx
  - src/app/(chat)/[brandId]/page.tsx
  - src/components/chat/chat-sidebar.tsx
autonomous: false

must_haves:
  truths:
    - "User can create a brand through chat conversation"
    - "Brand creation shows inline confirmation card"
    - "Conversation history persists across page refresh"
    - "Sidebar updates when new brand is created"
    - "User can clear conversation for a brand"
  artifacts:
    - path: "src/components/chat/brand-card.tsx"
      provides: "Inline brand creation card"
      min_lines: 25
    - path: "src/app/api/brands/route.ts"
      provides: "Brand CRUD API"
      exports: ["POST", "GET"]
    - path: "src/app/api/conversations/[conversationId]/messages/route.ts"
      provides: "Message loading endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/chat/route.ts"
      to: "src/lib/db/index.ts"
      via: "message persistence in onFinish"
      pattern: "db.insert.*messages"
    - from: "src/app/(chat)/[brandId]/page.tsx"
      to: "/api/conversations/[conversationId]/messages"
      via: "initial message load"
      pattern: "fetch.*messages"
    - from: "src/app/(chat)/page.tsx"
      to: "src/components/chat/chat-sidebar.tsx"
      via: "sidebar refresh after brand creation using SWR mutate"
      pattern: "mutate.*brands|useSWR.*brands"
---

<objective>
Implement brand creation flow through chat and message persistence to database

Purpose: Complete the chat interface by enabling brand creation (the core first-run experience) and ensuring conversations persist across sessions. This satisfies all Phase 2 success criteria.

Output:
- BrandCard component for inline brand confirmation
- Brand creation API (POST /api/brands)
- Message persistence in chat API (onFinish callback)
- Message loading API (GET /api/conversations/[id]/messages)
- Updated chat pages to load/persist messages
- Clear conversation functionality
- Sidebar refresh mechanism after brand creation
</objective>

<execution_context>
@C:\Users\gerar\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gerar\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-chat-interface/02-CONTEXT.md
@.planning/phases/02-chat-interface/02-RESEARCH.md
@.planning/phases/02-chat-interface/02-01-SUMMARY.md
@.planning/phases/02-chat-interface/02-02-SUMMARY.md

# Existing code to reference
@src/lib/db/schema.ts
@src/lib/db/index.ts
@src/stores/brand-store.ts
@src/stores/chat-store.ts
@src/app/api/chat/route.ts
@src/components/chat/chat-messages.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create brand and message APIs</name>
  <files>
    src/app/api/brands/route.ts
    src/app/api/conversations/[conversationId]/messages/route.ts
    src/app/api/chat/route.ts
  </files>
  <action>
Create the backend APIs for brand management and message persistence:

1. Create `src/app/api/brands/route.ts`:
   - GET: Return all brands from database, ordered by createdAt desc
   - POST: Create new brand with { name, description? }
     * Generate UUID for brand
     * Create brand record in database
     * Create default conversation for brand
     * Return { brand, conversationId }
   - Use db from src/lib/db/index.ts
   - Use brands, conversations tables from schema

2. Create `src/app/api/conversations/[conversationId]/messages/route.ts`:
   - GET: Load messages for conversation
     * Query messages table by conversationId
     * Order by createdAt asc
     * Transform to UIMessage format (id, role, parts: [{ type: 'text', text: content }])
     * Return { messages }
   - Handle 404 if conversation doesn't exist

3. Update `src/app/api/chat/route.ts` to persist messages:
   - Accept conversationId in request body
   - In real mode: Use toUIMessageStreamResponse with onFinish callback
     * In onFinish: save user message and assistant message to database
     * Get the last 2 messages (user + assistant) from finalMessages
     * Insert into messages table with conversationId, role, content
   - In mock mode: Also persist messages after streaming completes
   - Call result.consumeStream() (without await) per RESEARCH.md pitfall #3
   - If no conversationId provided, skip persistence (new chat flow handles this)
  </action>
  <verify>
Test APIs with curl:
```
# Create brand
curl -X POST http://localhost:3000/api/brands \
  -H "Content-Type: application/json" \
  -d '{"name":"Test Brand"}'

# Get brands
curl http://localhost:3000/api/brands

# Get messages (use conversationId from brand creation)
curl http://localhost:3000/api/conversations/[id]/messages
```
  </verify>
  <done>
Brand CRUD API works. Messages persist to database after chat. Messages can be loaded for a conversation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement brand creation flow in chat with sidebar refresh</name>
  <files>
    src/components/chat/brand-card.tsx
    src/components/chat/chat-messages.tsx
    src/components/chat/chat-sidebar.tsx
    src/app/(chat)/page.tsx
    src/lib/ai/chat.ts
  </files>
  <action>
Create the brand creation experience following CONTEXT.md decisions:

1. Create `src/components/chat/brand-card.tsx`:
   - 'use client' directive
   - Props: brandName (string), onConfirm () => void, onCancel () => void
   - Card styling using design system (card class)
   - Show brand name with placeholder color swatch
   - "Create Brand" primary button, "Cancel" secondary button
   - Clean, minimal design matching chat aesthetic

2. Update `src/lib/ai/chat.ts` system prompt:
   - Add instructions for brand creation flow:
     * When user's first message doesn't mention a brand, ask what brand they want to create
     * Guide toward getting a brand name
     * When user provides a name, confirm: "I'll create a brand called '[name]'. Ready to proceed?"
     * Include marker text that frontend can detect: [CREATE_BRAND:name]
   - Keep it conversational and helpful

3. Update `src/components/chat/chat-messages.tsx`:
   - Add prop: onCreateBrand (name: string) => void
   - After rendering messages, check last assistant message for [CREATE_BRAND:name] pattern
   - If found, render BrandCard below the message with extracted name
   - onConfirm: call onCreateBrand with name
   - onCancel: allow user to continue chatting (maybe say "let's try a different name")
   - Edge case handling: If user sends another message BEFORE clicking the confirmation card,
     hide the card (the new message supersedes the pending creation). The AI can re-offer
     brand creation after processing the new message.

4. Update `src/components/chat/chat-sidebar.tsx` to support refresh:
   - Use SWR for brand fetching: `useSWR('/api/brands', fetcher)`
   - Export a function or use SWR's global mutate to allow external refresh
   - On mount, fetch brands from /api/brands
   - After brands load, update brand store with fetched brands
   - Add "Clear Chat" option in brand context menu (right-click or three dots)

5. Update `src/app/(chat)/page.tsx` (new chat / no brand):
   - When user starts chatting, AI guides them to create a brand
   - Handle onCreateBrand callback:
     * Call POST /api/brands with the name
     * IMPORTANT: After brand creation, trigger sidebar refresh using SWR mutate:
       `mutate('/api/brands')` to refetch brand list
     * This ensures sidebar shows new brand immediately
     * Navigate to /[brandId] with the new brand
   - Show loading state during brand creation
  </action>
  <verify>
Manual test flow:
1. Go to http://localhost:3000 (root)
2. Type "I want to create a brand for my coffee shop called Brewster"
3. AI should recognize and respond with brand creation confirmation
4. BrandCard appears with "Brewster" and Create/Cancel buttons
5. Click Create Brand
6. Navigate to /[brandId], sidebar updates with new brand IMMEDIATELY (no page refresh needed)

Edge case test:
1. Start brand creation flow, see confirmation card
2. Type another message BEFORE clicking Create
3. Card should disappear, AI processes new message
  </verify>
  <done>
Brand creation works through chat. AI guides user to provide brand name. Confirmation card appears. Creating brand navigates to brand chat. Sidebar refreshes immediately via SWR mutate. Edge case handled for messages sent before confirmation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire message persistence and history loading</name>
  <files>
    src/app/(chat)/[brandId]/page.tsx
    src/app/api/conversations/[conversationId]/messages/route.ts
  </files>
  <action>
Complete the persistence layer and clear chat functionality:

1. Update `src/app/(chat)/[brandId]/page.tsx`:
   - On mount, fetch brand data to get conversationId
   - Fetch initial messages from /api/conversations/[id]/messages
   - Pass initialMessages to useChat hook (messages prop)
   - Use setMessages when conversationId changes (per RESEARCH.md pitfall #5)
   - Show loading state while fetching
   - Handle error state if brand/conversation not found

2. Add DELETE handler to `src/app/api/conversations/[conversationId]/messages/route.ts`:
   - Delete all messages for conversation
   - Keep the conversation record (just clear messages)
   - Return 204 No Content on success

3. Wire clear chat in sidebar (chat-sidebar.tsx already has the UI from Task 2):
   - On "Clear Chat" click: call DELETE /api/conversations/[id]/messages
   - After clearing: refresh the current chat view (if viewing that brand)
   - Use router.refresh() or SWR mutate for the messages endpoint
  </action>
  <verify>
Full persistence test:
1. Create a brand, send some messages
2. Refresh the page
3. Messages should load from database (not disappear)
4. Right-click brand in sidebar, click "Clear Chat"
5. Messages cleared, can start fresh conversation
  </verify>
  <done>
Messages persist across page refresh. Sidebar loads brands from API. Clear chat functionality works. Full Phase 2 chat experience complete.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete chat interface with brand creation, streaming messages, and persistence</what-built>
  <how-to-verify>
1. Open http://localhost:3000 in browser
2. Verify sidebar is visible on left with "Dobra" header
3. Type a message like "I want to create a brand called TestBrand"
4. Verify typing indicator appears (pulsing dots)
5. Verify AI response streams in (words appear progressively)
6. Verify brand creation card appears with "TestBrand" name
7. Click "Create Brand" button
8. Verify navigation to /[brandId] and sidebar shows new brand IMMEDIATELY
9. Send another message in the brand chat
10. Refresh the page (F5)
11. Verify messages persist (still visible after refresh)
12. Right-click brand in sidebar, verify "Clear Chat" option exists
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes
2. Brand creation flow works end-to-end
3. Messages persist to database
4. Messages load on page refresh
5. Sidebar shows all brands and refreshes immediately after creation
6. Clear chat removes messages
7. All Phase 2 success criteria met
</verification>

<success_criteria>
- User sees conversational chat interface as entry point
- Chat guides user through brand creation (name collection)
- User can name and identify brands within chat flow
- Chat messages stream in real-time
- Conversation history persists across browser sessions
- Inline brand card appears for confirmation
- Sidebar updates with new brands IMMEDIATELY (no manual refresh)
- Clear conversation option available
- Edge case: Messages sent before confirmation hide the pending card
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-interface/02-03-SUMMARY.md`
</output>
