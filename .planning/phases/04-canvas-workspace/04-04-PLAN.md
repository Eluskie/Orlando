---
phase: 04-canvas-workspace
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/app/(chat)/[brandId]/canvas/page.tsx
  - src/app/api/brands/[brandId]/assets/route.ts
  - src/components/canvas/canvas-workspace.tsx
  - src/app/(chat)/[brandId]/page.tsx
autonomous: false

must_haves:
  truths:
    - "User can navigate to /[brandId]/canvas to see brand canvas workspace"
    - "Canvas loads and displays assets belonging to the active brand"
    - "Switching brands clears canvas and loads new brand's assets"
    - "User can toggle between chat view and canvas view for a brand"
  artifacts:
    - path: "src/app/(chat)/[brandId]/canvas/page.tsx"
      provides: "Canvas workspace route"
      min_lines: 20
    - path: "src/app/api/brands/[brandId]/assets/route.ts"
      provides: "API to fetch brand assets"
      exports: ["GET"]
  key_links:
    - from: "src/app/(chat)/[brandId]/canvas/page.tsx"
      to: "src/components/canvas/canvas-workspace.tsx"
      via: "component import and render"
      pattern: "CanvasWorkspace"
    - from: "src/components/canvas/canvas-workspace.tsx"
      to: "/api/brands/[brandId]/assets"
      via: "fetch on mount/brand change"
      pattern: "fetch.*api/brands.*assets"
---

<objective>
Create the canvas route and integrate asset loading per brand workspace.

Purpose: Users need to access a canvas for each brand (CANV-01) and see their assets displayed (CANV-02). This plan connects the canvas UI to the data layer and provides navigation.

Output: A functional canvas page that loads brand-specific assets and provides navigation between chat and canvas views.
</objective>

<execution_context>
@C:\Users\gerar\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gerar\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-canvas-workspace/04-RESEARCH.md

@src/stores/canvas-store.ts
@src/stores/brand-store.ts
@src/lib/db/schema.ts
@src/components/canvas/canvas-workspace.tsx
@src/app/(chat)/[brandId]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create assets API endpoint</name>
  <files>
    src/app/api/brands/[brandId]/assets/route.ts
  </files>
  <action>
1. Create `src/app/api/brands/[brandId]/assets/route.ts`:
   - Import db from @/lib/db
   - Import assets table from @/lib/db/schema
   - Import eq from drizzle-orm
   - Import NextResponse from next/server

2. Implement GET handler:
   ```typescript
   export async function GET(
     request: Request,
     { params }: { params: Promise<{ brandId: string }> }
   ) {
     const { brandId } = await params;

     try {
       const brandAssets = await db
         .select()
         .from(assets)
         .where(eq(assets.brandId, brandId))
         .orderBy(assets.createdAt);

       return NextResponse.json(brandAssets);
     } catch (error) {
       console.error("Failed to fetch assets:", error);
       return NextResponse.json(
         { error: "Failed to fetch assets" },
         { status: 500 }
       );
     }
   }
   ```

3. The response will include canvasX, canvasY, canvasScale from database schema.

IMPORTANT: Use await params pattern (Next.js 15+ dynamic route params are Promises).
  </action>
  <verify>
    - `npm run build` passes
    - File exists: src/app/api/brands/[brandId]/assets/route.ts
    - Grep for "GET" in the route file returns a match
  </verify>
  <done>
    - GET /api/brands/[brandId]/assets returns array of assets
    - Assets include canvasX, canvasY, canvasScale fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Create canvas page and load assets</name>
  <files>
    src/app/(chat)/[brandId]/canvas/page.tsx
    src/components/canvas/canvas-workspace.tsx
  </files>
  <action>
1. Create `src/app/(chat)/[brandId]/canvas/page.tsx`:
   - Add "use client" directive
   - Import CanvasWorkspace from @/components/canvas
   - Import useCanvasStore from @/stores/canvas-store
   - Import useEffect from react

2. Implement CanvasPage component:
   - Extract brandId from params (await params for Next.js 15)
   - Get addObject, objects from useCanvasStore
   - Note: For server component params in client component, pass brandId as prop or use client-side routing

   Alternative pattern (simpler for Next.js 15 app router):
   ```typescript
   "use client";

   import { useParams } from "next/navigation";
   import { useEffect } from "react";
   import { CanvasWorkspace } from "@/components/canvas";
   import { useCanvasStore, type CanvasObject } from "@/stores/canvas-store";

   export default function CanvasPage() {
     const params = useParams<{ brandId: string }>();
     const brandId = params.brandId;
     const { objects, addObject } = useCanvasStore();

     // Load assets on mount and brand change
     useEffect(() => {
       if (!brandId) return;

       // Clear existing objects when brand changes
       useCanvasStore.getState().objects.forEach((obj) => {
         useCanvasStore.getState().removeObject(obj.id);
       });

       // Fetch brand assets
       fetch(`/api/brands/${brandId}/assets`)
         .then((res) => res.json())
         .then((assets) => {
           assets.forEach((asset: any) => {
             const canvasObj: CanvasObject = {
               id: asset.id,
               type: "image",
               x: asset.canvasX ?? 100 + Math.random() * 200,
               y: asset.canvasY ?? 100 + Math.random() * 200,
               width: asset.width ?? 200,
               height: asset.height ?? 200,
               rotation: 0,
               scaleX: asset.canvasScale ?? 1,
               scaleY: asset.canvasScale ?? 1,
               opacity: 1,
               visible: true,
               locked: false,
               src: asset.url,
             };
             addObject(canvasObj);
           });
         })
         .catch(console.error);
     }, [brandId, addObject]);

     return (
       <div className="flex-1 bg-gray-100">
         <CanvasWorkspace />
       </div>
     );
   }
   ```

3. The canvas workspace will render any objects in the store via the existing implementation.

IMPORTANT: Clear canvas objects when brand changes to prevent mixing assets.
IMPORTANT: Use random positioning as fallback if canvasX/canvasY are null (new assets).
  </action>
  <verify>
    - `npm run build` passes
    - File exists: src/app/(chat)/[brandId]/canvas/page.tsx
    - Grep for "CanvasWorkspace" in the page file returns a match
    - Grep for "/api/brands" in the page file returns a match
  </verify>
  <done>
    - Canvas page renders at /[brandId]/canvas route
    - Assets load from API and appear on canvas
    - Brand change clears old assets and loads new ones
  </done>
</task>

<task type="auto">
  <name>Task 3: Add navigation between chat and canvas</name>
  <files>
    src/app/(chat)/[brandId]/page.tsx
  </files>
  <action>
1. Update the brand chat page to add a link/button to canvas view:
   - Import Link from next/link
   - Import Layout icon from lucide-react (represents canvas/workspace)

2. Add a navigation element in the brand page header or near the moodboard:
   - Link to `/[brandId]/canvas`
   - Style as a button or icon link
   - Example placement near the moodboard toggle:
   ```tsx
   <Link
     href={`/${brandId}/canvas`}
     className="flex items-center gap-2 px-3 py-1.5 text-sm text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded-md transition-colors"
   >
     <Layout className="w-4 h-4" />
     <span>Open Canvas</span>
   </Link>
   ```

3. Consider placement:
   - Could be in the header area near brand name
   - Could be a tab-style toggle between Chat and Canvas views
   - For MVP, a simple link is sufficient

IMPORTANT: Keep existing chat functionality intact. This is additive navigation.
  </action>
  <verify>
    - `npm run build` passes
    - Grep for "canvas" in [brandId]/page.tsx returns a match
    - Grep for "Link" in [brandId]/page.tsx returns a match
  </verify>
  <done>
    - Brand page has link to canvas view
    - User can navigate from chat to canvas
    - Navigation maintains brand context
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete canvas workspace with:
    - Konva Stage with zoom (wheel) and pan (drag)
    - Image rendering from canvas store
    - Selection with Transformer handles
    - Resize/rotate via Transformer
    - Toolbar with undo/redo and zoom controls
    - Canvas route per brand with asset loading
    - Navigation between chat and canvas views
  </what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Navigate to http://localhost:3000
    3. Create or select a brand that has uploaded reference images (from Phase 3)
    4. Click "Open Canvas" link to navigate to canvas view
    5. Verify: Reference images appear on canvas
    6. Test zoom: Use mouse wheel - should zoom toward pointer
    7. Test pan: Drag empty canvas area - should pan
    8. Test select: Click an image - should show selection handles
    9. Test resize: Drag corner handle - image should resize
    10. Test undo: Click undo button - should revert last action
    11. Test zoom controls: Click zoom in/out buttons - should work
    12. Test fit: Click fit button - should reset to 100% at center
    13. Navigate back to chat view - canvas state should persist
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes
2. Canvas route accessible at /[brandId]/canvas
3. Assets load from database and display on canvas
4. Navigation works between chat and canvas views
5. All canvas interactions (zoom, pan, select, transform) work correctly
</verification>

<success_criteria>
- User has dedicated canvas per brand (CANV-01)
- Canvas displays brand assets (CANV-02)
- Zoom and pan work (CANV-04)
- Undo/redo work (CANV-05)
- Drag and arrange work (CANV-06)
- Workspace switching clears/loads correct assets (CANV-07)
- Toolbar visible with controls (UX-02)
</success_criteria>

<output>
After completion, create `.planning/phases/04-canvas-workspace/04-04-SUMMARY.md`
</output>
