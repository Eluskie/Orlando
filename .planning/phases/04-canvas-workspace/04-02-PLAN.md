---
phase: 04-canvas-workspace
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/components/canvas/canvas-workspace.tsx
  - src/components/canvas/canvas-transformer.tsx
  - src/components/canvas/canvas-image.tsx
  - src/hooks/use-canvas-interactions.ts
autonomous: true

must_haves:
  truths:
    - "User can zoom canvas with mouse wheel (zoom toward pointer)"
    - "User can pan canvas by dragging empty space"
    - "User can click an image to select it (shows selection handles)"
    - "User can resize/rotate selected image via Transformer handles"
  artifacts:
    - path: "src/hooks/use-canvas-interactions.ts"
      provides: "Wheel zoom handler with pointer anchoring"
      min_lines: 30
    - path: "src/components/canvas/canvas-transformer.tsx"
      provides: "Transformer wrapper for selection handles"
      min_lines: 25
  key_links:
    - from: "src/hooks/use-canvas-interactions.ts"
      to: "src/stores/canvas-store.ts"
      via: "setZoom, setPan"
      pattern: "setZoom|setPan"
    - from: "src/components/canvas/canvas-transformer.tsx"
      to: "react-konva Transformer"
      via: "useEffect attaching nodes"
      pattern: "transformerRef\\.current\\.nodes"
---

<objective>
Implement canvas interactions: wheel zoom with pointer anchoring, selection, and Transformer for resize/rotate.

Purpose: Without zoom/pan, large canvases are unusable. Without selection/transform, users cannot resize or rotate assets. These are core canvas manipulation features.

Output: Interactive canvas with zoom, pan, selection, and resize/rotate handles.
</objective>

<execution_context>
@C:\Users\gerar\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\gerar\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-canvas-workspace/04-RESEARCH.md

@src/stores/canvas-store.ts
@src/components/canvas/canvas-workspace.tsx
@src/components/canvas/canvas-image.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement wheel zoom and pan handling</name>
  <files>
    src/hooks/use-canvas-interactions.ts
    src/components/canvas/canvas-workspace.tsx
  </files>
  <action>
1. Create `src/hooks/use-canvas-interactions.ts`:
   - Import useCallback from react
   - Import Konva types: KonvaEventObject
   - Import useCanvasStore

2. Export useCanvasInteractions hook returning:
   - handleWheel: (e: KonvaEventObject<WheelEvent>) => void

3. Implement handleWheel following research pattern:
   ```typescript
   const handleWheel = useCallback((e: KonvaEventObject<WheelEvent>) => {
     e.evt.preventDefault();
     const stage = e.target.getStage();
     if (!stage) return;

     const scaleBy = 1.05;
     const oldScale = stage.scaleX();
     const pointer = stage.getPointerPosition()!;

     // Support both trackpad pinch (ctrlKey) and mouse wheel
     const direction = e.evt.ctrlKey
       ? -e.evt.deltaY > 0 ? 1 : -1
       : e.evt.deltaY > 0 ? -1 : 1;

     const newScale = Math.max(0.1, Math.min(5,
       direction > 0 ? oldScale * scaleBy : oldScale / scaleBy
     ));

     // Zoom toward pointer
     const mousePointTo = {
       x: (pointer.x - stage.x()) / oldScale,
       y: (pointer.y - stage.y()) / oldScale,
     };

     const newPos = {
       x: pointer.x - mousePointTo.x * newScale,
       y: pointer.y - mousePointTo.y * newScale,
     };

     stage.scale({ x: newScale, y: newScale });
     stage.position(newPos);

     setZoom(newScale);
     setPan(newPos.x, newPos.y);
   }, [setZoom, setPan]);
   ```

4. Update canvas-workspace.tsx:
   - Import useCanvasInteractions
   - Get handleWheel from hook
   - Add onWheel={handleWheel} to Stage
   - Keep Stage draggable for pan (already done in 04-01)

IMPORTANT: The wheel handler updates both Konva Stage (imperative) AND Zustand store (for persistence).
  </action>
  <verify>
    - `npm run build` passes
    - File exists: src/hooks/use-canvas-interactions.ts
    - Grep for "handleWheel" in canvas-workspace.tsx returns a match
    - Grep for "setZoom" in use-canvas-interactions.ts returns a match
  </verify>
  <done>
    - Wheel zoom works with pointer anchoring
    - Zoom respects min/max bounds (0.1 to 5)
    - Pan works via Stage drag (from 04-01)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement selection and Transformer</name>
  <files>
    src/components/canvas/canvas-transformer.tsx
    src/components/canvas/canvas-workspace.tsx
    src/components/canvas/canvas-image.tsx
    src/components/canvas/index.ts
  </files>
  <action>
1. Create `src/components/canvas/canvas-transformer.tsx`:
   - Import useRef, useEffect from react
   - Import Transformer from react-konva
   - Import Konva types
   - Import useCanvasStore

2. Create CanvasTransformer component:
   - Props: selectedIds: string[], layerRef: React.RefObject<Konva.Layer>
   - Create transformerRef: useRef<Konva.Transformer>(null)
   - useEffect that runs when selectedIds or layerRef changes:
     - If no transformer or layer ref, return
     - Map selectedIds to nodes using layerRef.current.findOne(`#${id}`)
     - Filter out nulls
     - Call transformerRef.current.nodes(nodes)
   - Return Transformer with ref={transformerRef}

3. Update canvas-image.tsx:
   - Add onClick handler that calls setSelection([object.id])
   - Add onTransformEnd handler that:
     - Gets node from e.target
     - Calculates actual dimensions: width * scaleX, height * scaleY
     - Resets scale to 1,1 on the node
     - Calls updateObject with new x, y, width, height, rotation
   - CRITICAL: The scale reset pattern from research:
     ```typescript
     onTransformEnd={(e) => {
       const node = e.target;
       const scaleX = node.scaleX();
       const scaleY = node.scaleY();

       node.scaleX(1);
       node.scaleY(1);

       updateObject(object.id, {
         x: node.x(),
         y: node.y(),
         width: Math.max(5, node.width() * scaleX),
         height: Math.max(5, node.height() * scaleY),
         rotation: node.rotation(),
       });
     }}
     ```

4. Update canvas-workspace.tsx:
   - Create layerRef: useRef<Konva.Layer>(null)
   - Pass ref={layerRef} to Layer
   - Import and render CanvasTransformer inside Layer, after all objects
   - Pass selectedIds and layerRef to CanvasTransformer
   - Add click handler on Stage to deselect when clicking empty space:
     ```typescript
     onClick={(e) => {
       if (e.target === e.target.getStage()) {
         setSelection([]);
       }
     }}
     ```

5. Update index.ts to export CanvasTransformer

IMPORTANT: Objects MUST have id prop set for Transformer to find them.
IMPORTANT: Transformer must render AFTER all objects in the Layer.
  </action>
  <verify>
    - `npm run build` passes
    - File exists: src/components/canvas/canvas-transformer.tsx
    - Grep for "onTransformEnd" in canvas-image.tsx returns a match
    - Grep for "setSelection" in canvas-workspace.tsx returns a match
  </verify>
  <done>
    - Clicking image selects it (updates store selectedIds)
    - Clicking empty canvas deselects all
    - Selected image shows Transformer handles
    - Resizing/rotating via handles updates object dimensions
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` passes
2. Wheel zoom works with pointer anchoring
3. Click selection works on images
4. Transformer handles appear on selected images
5. Resize/rotate updates persist to store
</verification>

<success_criteria>
- Wheel zoom zooms toward mouse pointer, not center
- Zoom bounds enforced (0.1x to 5x)
- Pan works via dragging empty canvas
- Click image to select, click empty to deselect
- Transformer shows resize/rotate handles on selection
- Resize calculates actual dimensions (not scale values)
</success_criteria>

<output>
After completion, create `.planning/phases/04-canvas-workspace/04-02-SUMMARY.md`
</output>
